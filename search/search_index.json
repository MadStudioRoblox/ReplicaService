{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>ReplicaService is a selective state replication system. ReplicaService helps you make server code which changes and replicates any state to select clients.</p> <p>Assume that a state (Wikipedia) is any kind of data that has a present version and may also change at any time in the future, as many times as necessary. The data about a player which you load up during gameplay or save to the DataStore is a state. The color of a part, text shown on a users screen and furniture placed in a player owned house are all states - ReplicaService helps you make server-side code to control and replicate any state to all clients at once or only a select few.</p> <p>A state (in layman\u2019s terms, a lua table that may contain almost anything) is wrapped with a Replica - like the name implies, it creates a replica (identical copy) of the wrapped state on the client-side of users you want to see that state. You may define clients who will see that replica, call mutator functions on the Replica to change the state (will change contents of the wrapped table) and make the clients listen to those changes or simply read the state whenever necessary. Furthermore, a Replica can be parented to another Replica (with a few exceptions discussed later), unloaded for select clients and, of course, destroyed.</p> <p>What's good about ReplicaService:</p> <ul> <li> <p>Just replication, whatever you need replicated - The goal of ReplicaService is to streamline custom Roblox object replication from server to client. ReplicaService avoids being redundant and tackles as few concerns as possible.</p> </li> <li> <p>Chunks &amp; player houses - Selective replication allows you to make a \"custom StreamingEnabled implementation\" with full server-side control - load in nearby chunks, load in interiors and furniture only when the player enters those areas!</p> </li> <li> <p>\"It don't go brrrrr\" - ReplicaService is completely event-based and only tells the client the data that changes - it keeps the network usage low and conserves computer resources.</p> </li> <li> <p>Go big, go small - Use custom mutators for minimal bandwith and gain access to client-side listeners that react to bulk changes instead of individual values. Use built-in mutators for rapid implementations while still keeping your network use very low.</p> </li> </ul> <p>If anything is missing or broken, file an issue on GitHub.</p> <p>If you need help integrating ReplicaService into your project, join the discussion.</p>"},{"location":"api/","title":"API","text":"<p>Warning</p> <p>Parameter limitations (developer.roblox.com) apply to <code>Replica.Tags</code>, <code>Replica.Data</code>, <code>Replica:FireClient()</code>, <code>Replica:FireAllClients()</code> and <code>Replica:FireServer()</code></p> <p>Error</p> <p>DO NOT YIELD (<code>wait()</code> or asynchronous tasks like <code>Instance:WaitForChild()</code>; Most methods / functions with <code>async</code> in their name) inside write functions or listener functions connected via <code>Replica:ListenToWrite()</code>, <code>Replica:ListenToChange()</code>, etc. Yielding in these places will cause ReplicaService / ReplicaController to skip replication events and lose data synchronization.</p> <p>Notice</p> <p>The <code>ReplicaController</code> and <code>ReplicaService</code> modules will yield on <code>require()</code> if the internally included modules are not found immediately</p>"},{"location":"api/#common-types","title":"Common types","text":"<p><code>path</code> - A path defines a location of a value within a dictionary (arrays will work too). Built-in mutators use the path variable to make the server and the client perform identical changes to their copy of the state. <pre><code>-- Using [table] type paths is highly recommended - string type paths\n--   will have a slightly bigger performance impact in large replica\n--   implementations\n\npath   [table] {\"Currencies\", \"Coins\"} -- Can use numeric indexes to\n--   locate values in an array\n\npath   [string] \"Currencies.Coins\" -- Use dots to separate multiple keys;\n--   Will only work on string keys\n</code></pre></p> <p><code>function_name</code> - Similar to <code>path</code>, locates a function within a WriteLib. <pre><code>function_name   [string] \"Currency.AddCoins\" -- Use dots to separate multiple keys;\n--   Functions and their categories may only have string keys\n\n-- It's highly recommended to avoid using function categories and\n--   keeping your WriteLib modules flat and short, dividing large\n--   replicas into several, smaller replicas with fewer concerns\n</code></pre></p>"},{"location":"api/#guarantees","title":"Guarantees","text":"<p>ReplicaService and ReplicaController perform all tasks and fire all new replica signals one at a time, one after another (sequential execution). Understanding the order of execution can help you make more efficient decisions in solving your problems.</p> <p>When a replica reference is received through <code>.NewReplicaSignal</code> or <code>.ReplicaOfClassCreated()</code>, ReplicaController provides these guarantees:</p> <ul> <li>Whenever any replica is received client-side, all descendants (all children &amp; children of children)       of that replica at the moment of replication (Parent set in <code>replica_params</code> or :ReplicateFor())       will be accessible on the client-side!</li> <li>When the client receives first data or receives selective replication of a top level replica,             <code>.NewReplicaSignal</code> and <code>.ReplicaOfClassCreated()</code> will be fired for all replicas in the       order they were created server-side from earliest to latest (Replica.Id       reflects this order). E.g. Creating <code>\"replica1\"</code> and then <code>\"replica2\"</code> in this order       server-side will make all clients create (and fire <code>.NewReplicaSignal</code> and <code>.ReplicaOfClassCreated()</code> for)       these replicas in the exact order assuming they are replicated to all players or are descendants       of the same top level replica at the moment of replication.</li> </ul>"},{"location":"api/#replicaservice","title":"ReplicaService","text":""},{"location":"api/#replicaserviceactiveplayers","title":"ReplicaService.ActivePlayers","text":"<p><pre><code>ReplicaService.ActivePlayers   [table] -- (read-only) {player = true, ...}\n</code></pre> A reference of players that have received initial data - having received initial data means having access to all replicas that are selectively replicated to that player.</p>"},{"location":"api/#replicaservicenewactiveplayersignal","title":"ReplicaService.NewActivePlayerSignal","text":"<p><pre><code>ReplicaService.NewActivePlayerSignal   [ScriptSignal] (player)\n</code></pre> A signal for new <code>ReplicaService.ActivePlayers</code> entries.</p>"},{"location":"api/#replicaserviceremovedactiveplayersignal","title":"ReplicaService.RemovedActivePlayerSignal","text":"<p><pre><code>ReplicaService.RemovedActivePlayerSignal   [ScriptSignal] (player)\n</code></pre> A signal for removed <code>ReplicaService.RemovedActivePlayerSignal</code> entries.</p>"},{"location":"api/#replicaservicetemporary","title":"ReplicaService.Temporary","text":"<p><pre><code>ReplicaService.Temporary   [Replica]\n</code></pre> A replica that is not replicated to any player and a \"helper\" for creating nested <code>Replica</code> objects when immediate replication of individual nested replicas is not desirable.</p> <p>ReplicaService.Temporary Example:</p> <p>Server-side: <pre><code>-- A valid use case is when it is desired for clients to receive a\n--   replica structure with all children replicated together as\n--   opposed to the client first receiving a parent creation signal\n--   (with missing children at that moment) and child creation\n--   signals coming in separately:\n\nlocal UseTemporary = true -- Set to false to make the replicas be\n--   replicated separately\n\nlocal ContainerReplica = ReplicaService.NewReplica({\n  ClassToken = ReplicaService.NewClassToken(\"SingletonContainerReplica\"),\n  Replication = \"All\",\n})\n\nlocal ReplicaClassToken1 = ReplicaService.NewClassToken(\"Class1\")\nlocal ReplicaClassToken2 = ReplicaService.NewClassToken(\"Class2\")\n\nlocal parent = ContainerReplica\nif UseTemporary == true then\n  parent = ReplicaService.Temporary\nend\n\nlocal nested_replica = ReplicaService.NewReplica({\n  ClassToken = ReplicaClassToken1, -- \"Class1\"\n  Parent = parent,\n})\nlocal child_replica = ReplicaService.NewReplica({\n  ClassToken = ReplicaClassToken2, -- \"Class2\"\n  Parent = nested_replica,\n})\n\nnested_replica:SetParent(ContainerReplica) -- Sets Parent to ContainerReplica\n--   if it wasn't already parented to ContainerReplica\n</code></pre></p> <p>Client-side: <pre><code>ReplicaController.ReplicaOfClassCreated(\"Class1\", function(replica)\n  print(#replica.Children) --&gt; Will print 1 when UseTemporary is set to true\n  --   or 0 when UseTemporary is set to false\n  coroutine.wrap(function()\n    wait()\n    print(#replica.Children) --&gt; Will always print 1 when UseTemporary\n    --   is set to true and is very likely, but not guaranteed to\n    --   print 1 when UseTemporary is set to false\n  end)()\nend)\n\nReplicaController.RequestData() -- Only using here for testing purposes\n--   ReplicaController.RequestData() should only be called once in the\n--   entire codebase!\n</code></pre></p>"},{"location":"api/#replicaservicenewclasstoken","title":"ReplicaService.NewClassToken()","text":"<p><pre><code>ReplicaService.NewClassToken(class_name) --&gt; [ReplicaClassToken]\n</code></pre> Class tokens for a particular <code>class_name</code> can only be created once - this helps the developer avoid <code>Replica</code> class name collisions when merging codebases.</p>"},{"location":"api/#replicaservicenewreplica","title":"ReplicaService.NewReplica()","text":"<p><pre><code>ReplicaService.NewReplica(replica_params) --&gt; [Replica]\n  replica_params   [table]:\n    {\n      ClassToken = replica_class_token,\n      -- Optional params (can be nil):\n      Tags = {}, -- {TagName = tag_value, ...}\n      Data = {}, -- Table to be replicated (Retains table reference)\n      Replication = \"All\" or {[Player] = true, ...} or [Player],\n      Parent = replica, -- [Replica]\n      WriteLib = write_lib_module, -- [ModuleScript]\n    }\n</code></pre> Creates a replica and immediately replicates to select active players based on replication settings of this <code>Replica</code> or the parent <code>Replica</code>.</p> <ul> <li>ClassToken - Sets <code>Replica.Class</code> to the string provided in <code>ReplicaService.NewClassToken(class_name)</code></li> <li>Tags - (Default: <code>{}</code> empty table) A dictionary of identifiers. Use <code>Tags</code> to let the client know which game objects the <code>Replica</code> belongs to: <code>Tags = {Part = part, Player = player, ...}</code>. Tags can't be changed after the <code>Replica</code> is created.</li> <li>Data - (Default: <code>{}</code> empty table) A table representing a state. Using <code>Profile.Data</code> from ProfileService is valid!</li> <li>Replication - (Default: <code>{}</code> not replicated to anyone) Pass <code>\"All\"</code> to replicate to everyone in the game and everyone who will join the game later. Pass <code>{Player = true, Player = true, ...}</code> dictionary or <code>Player</code> instance for selective replication.</li> <li>Parent - (Default: <code>nil</code>) Don't provide any value to create a top level replica - top level replicas can't be parented to other replicas and force their replication settings to all descendant nested replicas. Providing a parent creates a nested replica - nested replicas can be parented to any replica (except their own children), but they can't have their own replication settings. Hence the <code>Replication</code> and <code>Parent</code> parameters are mutually exclusive.</li> <li>WriteLib - (Default: <code>nil</code>) Provide a <code>ModuleScript</code> (not the return of <code>require()</code>) to assign write functions (mutator functions) to this replica. The <code>WriteLib</code> parameter is individual for every <code>Replica</code>.</li> </ul>"},{"location":"api/#replicacontroller","title":"ReplicaController","text":""},{"location":"api/#replicacontrollerinitialdatareceivedsignal","title":"ReplicaController.InitialDataReceivedSignal","text":"<p><pre><code>ReplicaController.InitialDataReceivedSignal   [ScriptSignal]()\n</code></pre> Fired once after the client finishes receiving initial replica data from server.</p>"},{"location":"api/#replicacontrollerinitialdatareceived","title":"ReplicaController.InitialDataReceived","text":"<p><pre><code>ReplicaController.InitialDataReceived   [bool]\n</code></pre> Set to true after the client finishes receiving initial replica data from server.</p>"},{"location":"api/#replicacontrollerreplicaofclasscreated","title":"ReplicaController.ReplicaOfClassCreated()","text":"<p><pre><code>ReplicaController.ReplicaOfClassCreated(replica_class, listener)\n    --&gt; [ScriptConnection] listener(replica)\n</code></pre> Listens to creation of replicas client-side of a particular class. <pre><code>ReplicaController.ReplicaOfClassCreated(\"Flower\", function(replica)\n    print(\"Flower replica created:\", replica:Identify())\n    print(replica.Class == \"Flower\") --&gt; true\nend)\n</code></pre> This is the preferred method of grabbing references to all replicas clients-side.</p>"},{"location":"api/#replicacontrollernewreplicasignal","title":"ReplicaController.NewReplicaSignal","text":"<p><pre><code>ReplicaController.NewReplicaSignal   [ScriptSignal] (replica)\n</code></pre> Fired every time a replica is created client-side. <pre><code>ReplicaController.NewReplicaSignal:Connect(function(replica)\n  print(\"Replica created:\", replica:Identify())\nend)\n</code></pre></p>"},{"location":"api/#replicacontrollergetreplicabyid","title":"ReplicaController.GetReplicaById()","text":"<p><pre><code>ReplicaController.GetReplicaById(replica_id) --&gt; [Replica] or nil\n</code></pre> Returns a <code>Replica</code> that is loaded client-side with a <code>Replica.Id</code> that matches <code>replica_id</code>.</p>"},{"location":"api/#replicacontrollerrequestdata","title":"ReplicaController.RequestData()","text":"<p><pre><code>ReplicaController.RequestData()\n</code></pre> Requests the server to start sending replica data.</p> <p>All <code>.NewReplicaSignal</code> and <code>.ReplicaOfClassCreated()</code> listeners should be connected before calling <code>.RequestData()</code>! - refrain from connecting listeners afterwards!</p> <p>If your game has local scripts that may run later during gameplay and they will need to interact with replicas, you should create a centralized module that connects <code>Replica</code> creation listeners before <code>.RequestData()</code> and provides those local scripts with the replica references they need.</p>"},{"location":"api/#replica","title":"Replica","text":""},{"location":"api/#shared-members","title":"Shared members","text":""},{"location":"api/#replicadata","title":"Replica.Data","text":"<p><pre><code>Replica.Data   [table] -- (read-only)\n</code></pre> Table representing the state wrapped by the <code>Replica</code>. Note that after wrapping a table with a <code>Replica</code> you may no longer write directly to that table (doing so would potentially desynchronize state among clients and in some cases even break code) - all changes must be applied through mutators. <pre><code>local PlayerStatsReplicaClassToken = ReplicaService.NewClassToken(\"PlayerStats\")\n\nlocal player -- A Player instance\nlocal data = {Coins = 100}\nlocal replica = ReplicaService.NewReplica({\n  ClassToken = PlayerStatsReplicaClassToken,\n  Tags = {Player = player},\n  Data = data, -- Replica does not create a deep copy!\n  Replication = \"All\",\n})\n\nprint(replica.Data == data) --&gt; true\nprint(replica.Data.Coins) --&gt; 100\nreplica:SetValue({\"Coins\"}, 420)\nprint(data.Coins, replica.Data.Coins) --&gt; 420 420\n</code></pre></p>"},{"location":"api/#replicaid","title":"Replica.Id","text":"<p><pre><code>Replica.Id   [number] -- (read-only)\n</code></pre> An identifier that is unique for every <code>Replica</code> within a Roblox game session.</p>"},{"location":"api/#replicaclass","title":"Replica.Class","text":"<p><pre><code>Replica.Class   [string] -- (read-only)\n</code></pre> The <code>class_name</code> parameter that has been used for the ReplicaClassToken used to create this <code>Replica</code>.</p>"},{"location":"api/#replicatags","title":"Replica.Tags","text":"<p><pre><code>Replica.Tags   [table] -- (read-only)\n</code></pre> A custom static <code>Replica</code> identifier mainly used for referencing affected game instances. Only used for properties that will not change for the rest of the <code>Replica</code>'s lifespan. <pre><code>local CharacterReplicaClassToken = ReplicaService.NewClassToken(\"Character\")\n\nlocal player -- A Player instance\nlocal character -- A Model instance\nlocal replica = ReplicaService.NewReplica({\n  ClassToken = CharacterReplicaClassToken,\n  Tags = {Player = player, Character = character, Appearance = \"Ninja\"},\n  Replication = \"All\",\n})\n</code></pre></p>"},{"location":"api/#replicaparent","title":"Replica.Parent","text":"<p><pre><code>Replica.Parent   [Replica] or nil -- (read-only)\n</code></pre> Reference to the parent <code>Replica</code>. All nested replicas will have a parent. All top level replicas will have their <code>Parent</code> property set to <code>nil</code>. nested replicas will never become top level replicas and vice versa.</p>"},{"location":"api/#replicachildren","title":"Replica.Children","text":"<p><pre><code>Replica.Children   [table] -- (read-only) {replica, ...} \n</code></pre> An array of replicas parented to this <code>Replica</code>.</p>"},{"location":"api/#replicaisactive","title":"Replica:IsActive()","text":"<p><pre><code>Replica:IsActive() --&gt; is_active [bool]\n</code></pre> Returns <code>false</code> if the <code>Replica</code> was destroyed.</p>"},{"location":"api/#replicaidentify","title":"Replica:Identify()","text":"<p><pre><code>Replica:Identify() --&gt; [string]\n</code></pre> Creates a brief string description of a <code>Replica</code>, excluding <code>Replica.Data</code> contents. Used for debug purposes. <pre><code>print(replica:Identify()) --&gt; \"[Id:7;Class:Flower;Tags:{Model=FlowerModel}]\"\n</code></pre></p>"},{"location":"api/#replicaaddcleanuptask","title":"Replica:AddCleanupTask()","text":"<p><pre><code>Replica:AddCleanupTask(task)\n--  task   [function] or [Instance] or [Object] (with :Destroy() or :Disconnect())\n</code></pre> Signs up a task, object, instance or function to be ran or destroyed when the <code>Replica</code> is destroyed. The cleanup task is performed instantly if the <code>Replica</code> is already destroyed. <pre><code>local FlowerReplicaClassToken = ReplicaService.NewClassToken(\"Flower\")\n\nlocal flower_model -- A Model instance\nlocal replica = ReplicaService.NewReplica({\n  ClassToken = FlowerReplicaClassToken,\n  Tags = {Model = flower_model},\n  Data = {\n    HasBees = false,\n    HoneyScore = 10,\n  },\n  Replication = \"All\",\n})\n\nreplica:AddCleanupTask(flower_model)\nreplica:Destroy() -- Destroys the replica for all subscribed clients first,\n--   then runs all the cleanup tasks including destroying the flower_model\n</code></pre></p>"},{"location":"api/#replicaremovecleanuptasktask","title":"Replica:RemoveCleanupTask(task)","text":"<p><pre><code>Replica:RemoveCleanupTask(task)\n</code></pre> Removes the cleanup task from the cleanup list.</p>"},{"location":"api/#built-in-mutators","title":"Built-in mutators","text":"<p>(<code>path</code> parameter is defined in CommonTypes)</p> <p>Mutators can alter any value in <code>Replica.Data</code> and replicate this change to players that have this <code>Replica</code> replicated to them. Mutators can only be used server-side or inside WriteLibs. Mutators will not trigger replication when called inside WriteLibs since the code is already going to be performed both on the server and client.</p> <p>Warning</p> <p>Just like with RemoteEvents, passing <code>value</code> as a reference to an instance which is not replicated to the player (e.g. parented to ServerScriptStorage / not parented to the DataModel) will make the client receive a nil value.</p>"},{"location":"api/#replicasetvalue","title":"Replica:SetValue()","text":"<p><pre><code>Replica:SetValue(path, value)\n</code></pre> Sets any individual value within <code>Replica.Data</code> to <code>value</code>. Parameter <code>value</code> can be <code>nil</code> and will set the value located in <code>path</code> to <code>nil</code>.</p>"},{"location":"api/#replicasetvalues","title":"Replica:SetValues()","text":"<p><pre><code>Replica:SetValues(path, values) \n</code></pre> Sets multiple keys located in <code>path</code> to specified <code>values</code> <pre><code>replica:SetValues({\"Fruit\"}, {\n  -- Notice: keys can't be paths here, only direct members\n  Apples = 5,\n  Oranges = 2,\n  -- WARNING: nil values will not work with replica:SetValues()\n  Bananas = nil, -- THIS IS INVALID, USE\n  --   Replica:SetValue({\"Fruit\", \"Bananas\"}, nil)\n})\nprint(replica.Data.Fruit.Oranges) --&gt; 2\n</code></pre></p>"},{"location":"api/#replicaarrayinsert","title":"Replica:ArrayInsert()","text":"<p><pre><code>Replica:ArrayInsert(path, value) --&gt; new_index [number]\n</code></pre> Performs <code>table.insert(t, value)</code> where <code>t</code> is a numeric sequential array <code>table</code> located in <code>path</code>.</p>"},{"location":"api/#replicaarrayset","title":"Replica:ArraySet()","text":"<p><pre><code>Replica:ArraySet(path, index, value)\n</code></pre> Performs <code>t[index] = value</code> where <code>t</code> is a numeric sequential array <code>table</code> located in <code>path</code>.</p>"},{"location":"api/#replicaarrayremove","title":"Replica:ArrayRemove()","text":"<p><pre><code>Replica:ArrayRemove(path, index) --&gt; removed_value\n</code></pre> Performs <code>table.remove(t, index)</code> where <code>t</code> is a numeric sequential array <code>table</code> located in <code>path</code>.</p>"},{"location":"api/#custom-mutators","title":"Custom mutators","text":"<p>Error</p> <p>Custom mutator functions must execute identical data changes on server and client given the same function parameters (Always assume <code>Replica.Data</code> of all replicated replicas are identical on server and client-side at the time of a write function execution). Implementing <code>RunService:IsServer()</code>, reading physical positions of parts or reading machine time (<code>os.clock()</code>, <code>tick()</code>, etc.) within write functions may lead to <code>Replica.Data</code> desynchronization between server and client-side and a collapse of stable behaviour from further replicated delta-data.</p> <p>In Layman's terms, a desyncronized client can be asked to add <code>1</code> to a value (Within <code>Replica.Data</code>, via a write function) which is equal to <code>100</code> locally, but is equal to <code>101</code> on the server, resulting in values <code>101</code> and <code>102</code> on client and server-side respectively. You may easily desynchronize machines by asking the server and client to add <code>os.clock()</code> to said value - <code>os.clock()</code> is always assumed to be a \"desynchronized\" value among all machinces and adding it to a synchronized value will desynchronize it. Due to Roblox physics being a partially locally simulated feature, desynchronization can also be done by using moving part position values.</p> <p>You may still use <code>os.clock()</code> or part positions passed as initial write function parameters on server-side so the client may repeat write function operations with identical function parameters.</p> <p>Keep it synchronized.</p>"},{"location":"api/#writelib","title":"WriteLib","text":"<p>A WriteLib is a <code>ModuleScript</code> containing a dictionary of mutator functions. When these functions are triggered using <code>Replica:Write()</code>, they will be called on both the server and all clients that have this <code>Replica</code> replicated to them. ReplicaService serializes all WriteLib functions to numbers, so only a small number is replicated as a reference to that function.</p> <p>WriteLib example structure:</p> <p>(<code>ModuleScript</code> WriteLib.lua - Must be a descendant of a replicated instance / container (e.g. ReplicatedStorage)) <pre><code>local WriteLib = {\n  -- Mutator functions will receive the first parameter as the\n  --   Replica being mutated; Custom parameters passed with\n  --   Replica:Write() will follow\n  RestockAll = function(replica, restock_count, max_count)\n    for soda_name, old_count in pairs(replica.Data.Cans) do\n      -- Using mutators inside WriteLibs will trigger client-side\n      --   listeners as expected:\n      replica:SetValue(\n        {\"Cans\", soda_name},\n        math.min(old_count + restock_count, max_count)\n      )\n    end\n  end,\n  TakeCan = function(replica, soda_name, amount) --&gt; amount_taken\n    local old_count = replica.Data.Cans[soda_name] or 0\n    local amount_taken = math.min(old_count, amount)\n    if amount_taken &gt; 0 then\n       replica:SetValue({\"Cans\", soda_name}, old_count - amount_taken)\n    end\n    return amount_taken\n  end,\n  AddCoins = function(replica, coin_count)\n    replica:SetValue({\"CoinsInside\"}, replica.Data.CoinsInside + coin_count)\n  end,\n  TakeAllCoins = function() --&gt; coins_taken\n    local coins = replica.Data.CoinsInside\n    replica:SetValue({\"CoinsInside\"}, 0)\n    replica:Write(\"RestockAll\", 1, 10) -- WriteLibs can use their own mutators!\n    return coins\n  end,\n  -- A note for power users:\n  --   replica.Children and replica.Parent can be accessed within\n  --   WriteLib mutator functions - built-in and custom mutators\n  --   can be triggered for those replicas as well. Go wild!\n}\n\nreturn WriteLib\n</code></pre></p> <p>(<code>Script</code> ReplicaTest.server.lua) <pre><code>local SodaMachineReplicaClassToken = ReplicaService.NewClassToken(\"SodaMachine\")\nlocal WriteLib = game.ReplicatedStorage:FindFirstChild(\"WriteLib\")\n\nlocal model -- A Model instance\nlocal replica = ReplicaService.NewReplica({\n  ClassToken = CoinReplicaClassToken,\n  Tags = {Model = model},\n  Data = {\n    Cans = {\n      Cola = 10,\n      Lemonade = 10,\n      RootBeer = 10,\n    },\n    CoinsInside = 0,\n  }, -- Replica does not create a deep copy!\n  Replication = \"All\",\n  WriteLib = WriteLib\n})\n\nlocal cola_click_detector -- Assume this is a ClickDetector of a cola button\nlocal restock_click_detector -- Assume this is a ClickDetector of a restock button\n\ncola_click_detector.MouseClick:Connect(function()\n  replica:Write(\"TakeCan\", \"Cola\", 1)\nend)\n\nrestock_click_detector.MouseClick:Connect(function()\n  replica:Write(\"RestockAll\", 1, 10)\nend)\n</code></pre></p> <p>(<code>LocalScript</code> ReplicaTest.client.lua) <pre><code>ReplicaController.ReplicaOfClassCreated(\"SodaMachine\", function(replica)\n\n  local machine_model = replica.Tags.Model\n\n  replica:ListenToWrite(\"TakeCan\", function(soda_name, amount)\n    -- Play sound on the client?\n    print(tostring(amount) .. \" can(s) of \" .. soda_name\n      .. \" have been taken from \" .. tostring(machine_model))\n  end)\n\n  replica:ListenToWrite(\"RestockAll\", function(restock_count, max_count)\n    print(tostring(machine_model) .. \" has been restocked! (\"\n      .. tostring(restock_count) .. \" each)\")\n  end)\n\n  replica:ListenToChange({\"Cans\", \"Cola\"}, function(new_value)\n    print(\"Coke can count has changed:\", new_value)\n  end)\n\n  -- Notice: You don't need to disconnect Replica listeners as the listeners\n  --    will be forgotten when the Replica is destroyed\n\nend)\n</code></pre></p> <p>Notice</p> <p>Be aware that things like <code>os.clock()</code> will have different values on the server and client when referenced inside a WriteLib. Instead you can make the server pass such values as parameters to a mutator function.</p>"},{"location":"api/#replicawrite","title":"Replica:Write()","text":"<p>(<code>function_name</code> parameter is defined in CommonTypes) <pre><code>Replica:Write(function_name, params...) --&gt; params...\n--    Returns anything the write function returns\n</code></pre> Calls a function within a WriteLib that has been assigned to this <code>Replica</code> for both the server and all clients that have this <code>Replica</code> replicated to them.</p>"},{"location":"api/#server-replicaservice","title":"Server (ReplicaService)","text":""},{"location":"api/#replicasetparent","title":"Replica:SetParent()","text":"<p><pre><code>Replica:SetParent(replica)\n</code></pre> Changes the <code>Parent</code> of the <code>Replica</code>.</p> <p>Only nested replicas can have their parents changed (nested replicas are replicas that were initially created with a parent).</p> <p>If a <code>Replica</code>, from a single player's perspective, is moved from a non-replicated parent to a replicated parent, the replica will be created for the player as expected. Likewise, parenting a replica to a non-replicated replica will destroy it for that player. This feature is useful for controlling visible game chunks with entities that can move between those chunks.</p>"},{"location":"api/#replicareplicatefor","title":"Replica:ReplicateFor()","text":"<p><pre><code>Replica:ReplicateFor(\"All\") -- Replicates the Replica to everyone in the game and\n--   everyone who will join in the future\nReplica:ReplicateFor(player) -- Selectively replicates the replica to a Player;\n--   Will not alter replication when the Replica is already replicated to \"All\"\n</code></pre> Changes replication settings (subscription settings) for select players.</p> <p>Only top level replicas can have their replication settings changed (top level replicas are replicas that were initially created without a parent).</p>"},{"location":"api/#replicadestroyfor","title":"Replica:DestroyFor()","text":"<p><pre><code>Replica:DestroyFor(\"All\") -- Destroys the Replica for all clients that had\n--   this replica replicated; Disables replication for future players\nReplica:DestroyFor(player) -- Selectively destroys the replica for a Player\n</code></pre> Changes replication settings (subscription settings) for select players.</p> <p>Only top level replicas can have their replication settings changed (top level replicas are replicas that were initially created without a parent).</p> <p>Warning</p> <p>Selectively destroying <code>Replica:DestroyFor(player)</code> for clients when the replica is replicated to <code>\"All\"</code> will throw an error - Call <code>Replica:DestroyFor(\"All\")</code> first.</p>"},{"location":"api/#replicaconnectonserverevent","title":"Replica:ConnectOnServerEvent()","text":"<p><pre><code>Replica:ConnectOnServerEvent(listener) --&gt; [ScriptConnection] (player, params...)\n</code></pre> Simulates the behaviour of RemoteEvent.OnServerEvent.</p>"},{"location":"api/#replicafireclient","title":"Replica:FireClient()","text":"<p><pre><code>Replica:FireClient(player, params...)\n</code></pre> Simulates the behaviour of RemoteEvent:FireClient().</p>"},{"location":"api/#replicafireallclients","title":"Replica:FireAllClients()","text":"<p><pre><code>Replica:FireAllClients(params...)\n</code></pre> Simulates the behaviour of RemoteEvent:FireAllClients().</p>"},{"location":"api/#replicadestroy","title":"Replica:Destroy()","text":"<p><pre><code>Replica:Destroy()\n</code></pre> Destroys replica and all of its descendants (Depth-first). <code>Replica</code> destruction signal is sent to the client first, while cleanup tasks assigned with <code>Replica:AddCleanupTask()</code> will be performed after.</p>"},{"location":"api/#client-replicacontroller","title":"Client (ReplicaController)","text":"<p>(<code>path</code> and <code>function_name</code> parameters are defined in CommonTypes)</p>"},{"location":"api/#replicalistentowrite","title":"Replica:ListenToWrite()","text":"<p><pre><code>Replica:ListenToWrite(function_name, listener) --&gt; [ScriptConnection]\n--   listener   [function] (params...)\n</code></pre> Listens to WriteLib mutator functions being triggered. See WriteLib section for examples.</p>"},{"location":"api/#replicalistentochange","title":"Replica:ListenToChange()","text":"<p><pre><code>Replica:ListenToChange(path, listener) --&gt; [ScriptConnection]\n--   listener   [function] (new_value, old_value)\n</code></pre> Creates a listener which gets triggered by <code>Replica:SetValue()</code> calls.</p>"},{"location":"api/#replicalistentonewkey","title":"Replica:ListenToNewKey()","text":"<p><pre><code>Replica:ListenToNewKey(path, listener) --&gt; [ScriptConnection]\n--   listener   [function] (new_value, new_key)\n</code></pre> Creates a listener which gets triggered by <code>Replica:SetValue()</code> calls when a new key is created inside <code>path</code> (value previously equal to <code>nil</code>). Note that this listener can't reference the key itself inside <code>path</code>.</p>"},{"location":"api/#replicalistentoarrayinsert","title":"Replica:ListenToArrayInsert()","text":"<p><pre><code>Replica:ListenToArrayInsert(path, listener) --&gt; [ScriptConnection]\n--   listener   [function] (new_index, new_value)\n</code></pre> Creates a listener which gets triggered by <code>Replica:ArrayInsert()</code> calls.</p>"},{"location":"api/#replicalistentoarrayset","title":"Replica:ListenToArraySet()","text":"<p><pre><code>Replica:ListenToArraySet(path, listener) --&gt; [ScriptConnection]\n--   listener   [function] (index, new_value)\n</code></pre> Creates a listener which gets triggered by <code>Replica:ArraySet()</code> calls.</p>"},{"location":"api/#replicalistentoarrayremove","title":"Replica:ListenToArrayRemove()","text":"<p><pre><code>Replica:ListenToArrayRemove(path, listener) --&gt; [ScriptConnection]\n--   listener   [function] (old_index, old_value)\n</code></pre> Creates a listener which gets triggered by <code>Replica:ArrayRemove()</code> calls.</p>"},{"location":"api/#replicalistentoraw","title":"Replica:ListenToRaw()","text":"<p><pre><code>Replica:ListenToRaw(listener) --&gt; [ScriptConnection]\n--   listener   [function] (action_name, path_array, params...)\n</code></pre> Allows the developer to parse exact arguments that have been passed to any of the built-in mutators.</p> <p>Possible parameter reference for <code>Replica:ListenToRaw()</code>: <pre><code>-- (\"SetValue\", path_array, value)\n-- (\"SetValues\", path_array, values)\n-- (\"ArrayInsert\", path_array, value)\n-- (\"ArraySet\", path_array, index, value)\n-- (\"ArrayRemove\", path_array, index, old_value)\n\n-- path_array   [table] -- table type path\n</code></pre></p>"},{"location":"api/#replicalistentochildadded","title":"Replica:ListenToChildAdded()","text":"<p><pre><code>Replica:ListenToChildAdded(listener) --&gt; [ScriptConnection]\n--   listener   [function] (replica)\n</code></pre> Creates a listener which gets triggered when a new child <code>Replica</code> is created.</p>"},{"location":"api/#replicafindfirstchildofclass","title":"Replica:FindFirstChildOfClass()","text":"<p><pre><code>Replica:FindFirstChildOfClass(replica_class) --&gt; [Replica] or nil\n--   replica_class   [string] -- Matches with Replica.Class\n</code></pre> Returns a first child <code>Replica</code> of specified class if one exists.</p>"},{"location":"api/#replicaconnectonclientevent","title":"Replica:ConnectOnClientEvent()","text":"<p><pre><code>Replica:ConnectOnClientEvent(listener) --&gt; [ScriptConnection]\n--   listener   [function] (params...)\n</code></pre> Simulates the behaviour of RemoteEvent.OnClientEvent.</p>"},{"location":"api/#replicafireserver","title":"Replica:FireServer()","text":"<p><pre><code>Replica:FireServer(params...)\n</code></pre> Simulates the behaviour of RemoteEvent:FireServer().</p>"},{"location":"tutorial/basic_usage/","title":"Basic Usage","text":"<p>This might not be the most useful, but it's the most basic implementation you can write with ReplicaService:</p> <p>(<code>Script</code> ReplicaTest.server.lua) <pre><code>local ReplicaService = require(game.ServerScriptService.ReplicaService)\n\nlocal test_replica = ReplicaService.NewReplica({\n    ClassToken = ReplicaService.NewClassToken(\"TestReplica\"),\n    Data = {Value = 0},\n    Replication = \"All\",\n})\n\nwhile task.wait(1) do\n    test_replica:SetValue({\"Value\"}, test_replica.Data.Value + 1)\nend\n</code></pre></p> <p>(<code>LocalScript</code> ReplicaTest.client.lua) <pre><code>local ReplicaController = require(game.ReplicatedStorage.ReplicaController)\n\nReplicaController.ReplicaOfClassCreated(\"TestReplica\", function(replica)\n    print(\"TestReplica received! Value:\", replica.Data.Value)\n\n    replica:ListenToChange({\"Value\"}, function(new_value)\n        print(\"Value changed:\", new_value)\n    end)\nend)\n\nReplicaController.RequestData() -- This function should only be called once\n--   in the entire codebase! Read the documentation for more info.\n</code></pre></p>"},{"location":"tutorial/settingup/","title":"Setting up","text":"<p>ReplicaService is a collection of module scripts. Your goal is to make your project have these files in the correct containers (\"Experimental\" and \"Examples\" folders are optional):</p> <p></p>"},{"location":"tutorial/settingup/#option-1-get-replicaservice-from-the-roblox-library","title":"Option #1: Get ReplicaService from the Roblox library","text":"<ul> <li>Get the library model here</li> <li>Move all modules to the correct containers to match the image above</li> </ul>"},{"location":"tutorial/settingup/#option-2-advanced-users-rojo","title":"Option #2: (Advanced users) Rojo","text":"<ul> <li>The ReplicaService package has Rojo configurations - download the  ReplicaService repository</li> <li>Sync project with Rojo. If it's your first time using Rojo, here's a tutorial</li> </ul>"},{"location":"tutorial/settingup/#running-examples","title":"Running examples:","text":"<p>Select an example and move it's files accordingly:</p> <p></p> <p>It should work when you play solo (or online, or offline with multiple players). Try joining with one player and then see what happens when you join with another player while running these tests.</p> <p>These tests are designed to be ran one at a time and will most likely interfere with an existing codebase that uses ReplicaService due to them calling ReplicaController.RequestData() -  this method should only be called once in the entire codebase (See API for more info).</p>"}]}